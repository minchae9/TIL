# 단계별로 이해하기
"""
8
0 0 1 1 1 1 1 1
1 0 0 0 0 0 0 1
1 1 1 0 1 1 1 1
1 1 1 0 1 1 1 1
1 0 0 0 0 0 0 1
1 0 1 1 1 1 1 1
1 0 0 0 0 0 0 0
1 1 1 1 1 1 1 0

앞걸음질과 뒷걸음질 할 때의 해야할 일이 다름
- 재귀호출 부분
탐색방향 정하기: 예) 시계방향: 오 하 왼 상
1) (i, j)에 방문 표시
2) 탐색방향을 보고, 미로를 벗어나지 않은 채로 갈 수 있으면 간다.
각각의 if문으로 차례로 탐색한다. (if-elif 말고)
or
델타 이용하여 각 방향 탐색

- 재귀 중단 조건 부분
i) 모든 칸을 방문. 도착점에 방문한 기록이 있으면, 경로가 존재한다. --- f1
- 방문기록 남기는 방법:
visited라는 미로와 똑같이 생긴 배열에 기록하는 방법(거리 따질 때 필요)
or (경로의 존재 유무는) 한 번 방문한 점은 재방문할 필요가 없으므로, 통로를 벽으로 바꾸는 작업
    ㄴ 이 경우에는 뒷걸음질 할 때는 벽인지 통로인지 구분 않고 왔던 길을 되돌아왔던 식으로.
    ㄴ 지나온 이전 경로를 저장하고 있기 때문에 별도의 stack이 필요없다.
(어제 순열 만드는 거랑 비슷한 느낌!!)
ii) 도착점에 도착하면 탐색을 중단하는 방법. ((쪼끔 줄일 수 있음)) --- f2
"""
def f1(i, j, N):    # 모든 칸을 방문하는 탐색
    maze[i][j] = 1  # (i, j) 방문표시. (진입한 칸은 벽으로 변경)
    for di, dj in [(0,1), (1,0), (0,-1), (-1,0)]:   # 4방향 탐색(오, 아래, 왼, 위)
        ni, nj = i+di, j+dj
        if 0<=ni<N and 0<=nj<N and maze[ni][nj] == 0:   # 탐색 방향이 통로이면
            f1(ni, nj, N)   # 이게 존재하지 않으면, 이전 함수로 return 되니까, 즉 지난 경로로 돌아가는 꼴이 됨.

N = int(input())
maze = [list(map(int, input().split())) for _ in range(N)]
# f1(0, 0, N)     # 탐색 시작은 (0, 0), 미로의 크기 N (미로 밖으로 나가는 것을 막기 위함)
# print(maze[N-1][N-1])   # 방문했으면 1일 거고(벽으로 바뀜), 아니면 0일 것





def f2(i, j, N):    # 출구를 찾으면 중단
    if i==N-1 and j == N-1: # 도착한 경우
        return 1
    maze[i][j] = 1  # 위의 탐색 방식과 같음
    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
        ni, nj = i + di, j + dj
        if 0 <= ni < N and 0 <= nj < N and maze[ni][nj] == 0:
            if f2(ni, nj, N):   # 출구를 찾고 리턴하면
                return 1        # 입구까지 리턴(남겨둔 갈림길을 탐색하지 않음) - 출구 찾았으니 for문도 끝!
    return 0                    # 탐색 방향에서 출구를 찾지 못한 경우

N = int(input())
maze = [list(map(int, input().split())) for _ in range(N)]
# f2(0, 0, N)




"""
방문 표시는 해야 하는데, 중복 방문이 허용되어야 함. (서로 다른 경로도 겹치는 부분이 있을 수 있으므로)
-> 풀어주기(???)
"""
def f3(i, j, N):    # 입구 -> 출구 경로의 개수
    global cnt
    if i == N-1 and j == N-1:
        cnt += 1            # 경로에 도착한 횟수
        return              # 다른 경로도 계속 탐색함
    else:
        maze[i][j] = 2      # 이걸 안하면, 무한루프에 빠질 수 있음 (방문했던 곳 재방문하면서)
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            ni, nj = i + di, j + dj
            if 0<=ni<N and 0<=nj<N and maze[ni][nj]==0:
                f3(ni, nj, N)
        maze[i][j] = 0  # 다른 경로에서의 i,j 진입은 허용 (더 이상 갈 수 있는 곳 없을 때 재방문할 수 있도록?)


N = int(input())
maze = [list(map(int, input().split())) for _ in range(N)]
# cnt = 0
# f3(0, 0, N)
# print(cnt)



"""
최단거리 찾기 - 모든 경로를 탐색해야 함
"""
def f4(i, j, N, c): # c 지나온 칸의 개수, 최단 거리 찾기... 모든 경로를 탐색(f1 코드 이용)
    global minV
    
    
    
N = int(input())
maze = [list(map(int, input().split())) for _ in range(N)]
