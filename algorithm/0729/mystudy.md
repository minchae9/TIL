#0729

## 스택과 큐

# [BOJ_10828](https://www.acmicpc.net/problem/10828)

### 기본 개념: 스택(stack)

쌓아올리다, 쌓아올린 것이라는 뜻.

무언가를 쌓을 때 우리는 바닥부터 시작하여 위로 계속 쌓아올린다. 맨 아래 장을 빼려면 맨 위에서부터 하나씩 빼야한다. 

스택도 이와 같다. 한 쪽만 뚫려 있어 입출구가 같은 파이프를 생각하면 된다. 한 쪽으로만 물건을 넣을 수 있고, 물건을 빼려면 넣었던 곳에서 마지막에 넣은 것부터 빼내야 한다: *LIFO(Last-in First-out)*

#### 나의 풀이

문제에 쓰여진대로 그대로 만들었다. 

각 경우를 if - elif - else 문으로 나누어 각 상황에서 어떤 작업을 수행할지 작성했다.

새로운 도구를 사용한 게 있다면, input을 받는 방법!

`input()`으로 입력값을 받으면 런타임에러가 종종 발생한다. 그래서 구글링해보니 다들 `sys`모듈을 불러와서 `sys.stdin.readline()`으로 받더라. 이전에도 쓴 적이 있었다면, 이번에는 조금 더 적극적으로 사용해 보았다.

#### 보완할 점

7행에서, `sys.stdin.readline().split()`은 결과물을 리스트로 반환해준다. 고로, `list()` 함수로 묶어줄 필요가 없다. 

<br/>

---

# [BOJ 10773](https://www.acmicpc.net/problem/10773)

#### 나의 풀이

스택 개념을 활용한 문제인데, 내 기억 상으로 꽤 간단하게 풀었던 것 같다.

부르는 숫자를 리스트에 `.append()` 메서드로 넣고, 0으로 정정하려면 `.pop()`으로 맨 뒤의 숫자를 빼내는 식이다. 그리고 마지막에 리스트 전체 요소들의 합을 반환했다.

<br/>

---

# [BOJ 18258](https://www.acmicpc.net/problem/18258)

### 기본 개념: 큐(queue)

맛집 줄서기를 생각하면 된다. 줄 선 순서대로 들어간다. 늦게 온 사람이 먼저 들어가는 일 따윈 없다. 

사람들은 줄의 끝에서 들어와 줄의 머리 방향으로 나간다. 즉, 입출구가 구분되어 있고, 입구는 입구 역할만, 출구는 출구 역할만 하는 것이다. 따라서, 먼저 들어온 요소부터 빠질 수 있다: *FIFO(First-in First-Out)*

#### 나의 풀이

BOJ 10828 (스택) 문제를 풀 때와 마찬가지로, 문제에 쓰여진 큐의 작동 원리를 if-elif-else 문으로 케이스를 나누어 구현했다. 

이번에는 `collections`라는 모듈을 가져와서 `collections.deque()` 기능과 `.popleft()`를 사용해 보았다. 큐(queue) 문제를 풀 때 런타임에러를 방지하기 위해 리스트 대신에 사용할 수 있는 도구라고 한다.

*참고: deque는 queue와 비슷한데, 다만 양쪽 구멍이 입구와 출구 역할을 모두 한다고 보면 될 것 같다. 그야말로 파이프다. 왼쪽과 오른쪽 끝에서 요소를 넣을 수 있고, 양쪽 모두에서 요소를 뺄 수도 있다. `deque` 모듈은 이를 구현할 수 있는 라이브러리라고 한다.

▶ [파이썬 도큐먼트에서 'deque 객체' 더 알아보기](https://docs.python.org/ko/3/library/collections.html?highlight=deque#collections.deque)

#### 보완할 점

스택 문제에서와 마찬가지로, `sys.stdin.readline().split()`의 결과물을 list 함수로 또다시 받을 필요가 없다는 점이다.

그리고 스터디원이 스택과 큐 문제를 클래스를 구현해서 푼 것을 봤는데, 스택과 큐의 여러 가지 작동 원리를 인스턴스 메서드로 구현해 보는 것도 좋은 연습이라는 생각이 들었다.

<br/>

---

# [BOJ 2164](https://www.acmicpc.net/problem/2164)

#### 나의 풀이

BOJ 10773(스택 활용) 문제처럼, 큐를 활용한 낮은 단계의 문제였다. (수학익힘책 느낌)

홀수 번째 시도는 인덱스가 짝수다. 그래서 인덱스가 짝수일 때, `.popleft()`로 카드를 버리게 했다.

짝수 번째 시도는 인덱스가 홀수다. 인덱스가 홀수일 때, `.popleft()`로 카드를 뽑되, 이것을 변수에 저장하고 리스트의 맨 마지막에 붙였다.

이 루틴을 반복하는 횟수가 카드 개수의 2배를 넘지 않을 거라는 건 자명했다. 왜냐하면, 첫 번째 순환에서 홀수 번째 카드를 모두 날리는 데에 최소 (n-1), 최대 n번. 이후 반으로 줄어든 카드를 또 하는 데에는 최대 n/2 번.

n + n/2 + n/4 + ... = n * (1 + 1/2 + 1/4 + ...) = 2n * (1 - (1/2)^n) < 2n

그래서 for 반복문의 범위는 2 * N으로 정했다.

#### 보완할 점

for loop 반복횟수를 더 잘 정할 수 있는 방법이 있을 것이다. 사실은 범위를 어떻게 정해야 적절할지 잘 몰랐기 때문에 2*N으로 정한 것이다.

<br/>

*끝*