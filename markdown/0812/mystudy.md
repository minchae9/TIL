#0812

# 비트 연산자

A = [1, 2, 3] 라는 배열이 있다고 하자.

우리는 각 요소를 0부터 4까지의 인덱스로 순서대로 접근할 수 있다.

부분집합을 만들기 위해, 각 요소의 포함여부를 0과 1로 표현해보자. 그리고, 표현된 수를 2진수라고 생각했을 때 10진수로 변환한 값을 알아보자.

**1** 	**2** 	**3**					**십진수 변환**

0 	0 	0							0

0 	0 	1							1

0 	1 	0							2

0 	1 	1							3

1 	0 	0							4

1 	0 	1							5

1 	1 	0							6

1 	1 	1							7



위에서 볼 수 있듯이, 10진수(예: 2^3)를 2진수로 표현하여, 0과 1이 각각 원소의 비포함과 포함을 나타내가 한다면, 제시된 요소들로 가능한 모든 부분집합을 나타낼 수 있다.

이제, 위의 요소 1, 2, 3을 각각 비트의 자리 수로 나타내보고자 한다.

비트는 뒤에서부터 적으니 각각 b2, b1, b0 자리라고 하고 역순으로 적겠다.

**b2 (A[0])** 	**b1 (A[1])** 	**b0 (A[0])**

​		0 				0 				0

​		0 				0 				1

​		0 				1 				0

​		0 				1 				1

​		1 				0 				0

​		1 				0 				1

​		1 				1 				0

​		1 				1 				1

이제, 우리는 비트 x번 자리에 1이 있으면, A[x] 요소가 부분집합에 포함되어 있다고 말할 수 있다.

부분집합을 만드는 코드로 살펴보자:

```python
s = 0
cnt = 0
for i in range(1<<n):			# (1)
    for j in range(n+1):
        if i & (1<<j):			# (2) j번 비트가 1일 때, i의 j번 자리도 1이면 1이 나옴 -> True
            print(arr[j], end=', ')  # 부분집합의 요소가 나옴
            s += arr[j]				# 부분집합의 합
            cnt += 1				# 부분집합 원소의 개수
```

(1) 1<<n은 2^n과 같다고 보면 된다. 무슨 밀아냐 하면, `1<<n`은 1을 n만큼 왼쪽으로 옮긴다(시프트)는 뜻인데, n이 0일 때 1, n이 1일 때 10, n이 2일 때 100, ⋯. 이것들을 모두 2진수라고 생각하여 10진수로 변환하면 1, 2, 4, ⋯ 로 2^n로 나타남을 알 수 있다. 여기서는 가능한 모든 부분집합을 만들겠다는 의미이다. 

이때, 배열에서 인덱스가 x인 요소를 포함하면, i의 x번째 비트는 1이고, 포함하지 않으면 0이다.

(2) 비트 연산에서 `& 연산자`는 모두 1이면 결과값이 1이고, 하나라도 0이면 0이다. 따라서, i와, 1을 j만큼 왼쪽으로 옮긴 값 (즉, j번째 비트만 1이고 나머지는 0인)의 각 자리를 비교했을 때, 둘 모두에서 값이 1이면, 조건식이 0이 아니므로 True가 된다. `1<<j`는 j번째 비트 자리수에만 1이므로, 이는 i의 j번째 자리수에 1이 있다면 True, 아니면 False라는 것이다. 즉, 이 조건식이 참이라면 A[x] 요소는 i 부분집합의 요소이므로 결과값이 나오게 된다.

i 하나당 하나의 부분집합이므로, 배열의 인덱스 값을 돌아가며 원소가 존재하는지 확인하여 이를 종합하면 하나의 부분집합을 구할 수 있다.

*끝*