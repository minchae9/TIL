# 스택 (1)

## 1. 스택

> "쌓아 올린" 형태의 자료구조

- 선형 구조: 자료 간 관계가 1:1, 즉 한 줄로 늘어선 형태. 다른 요소의 앞과 뒤를 통해 표현된다.

  (*비선형 구조는 자료 간 관계가 1:N 또는 N:M 관계)

- LIFO(후입선출): 자료를 넣은 역순으로 자료를 꺼낼 수 있다.

### 자료구조

마지막으로 저장된 요소의 위치를 'top'이라고 부른다.

### 연산

1) 저장(삽입): "push"

2) 삭제: 꺼내는 것. "pop"

3) 공백인지 확인: "isEmpty"

   공백이 아닌지 확인: "isNotEmpty" (주로 `isEmpty`가 없어서 `!isEmpty`로 활용하지 못할 때 사용)

4) top 요소를 읽어오기: "peek" (※ 꺼내는 것 아님)

### 스택의 구현

- 공백 스택: 요소가 없으니 top은 바닥을 가리킴 (top의 초기갑은: -1)

- push가 들어오면 → top을 하나 증가시킨다.

  i) top이 가리키는 자리를 이동시키고, ii) 가리키는 자리에 요소를 저장한다.

- pop이 들어오면 → top을 하나 감소시킨다.

  i) top이 가리키는 요소를 꺼내고, ii) top을 감소시킨다 OR i) top을 감소시키고, ii) top+1 의 요소를 반환한다.

  +

  top의 자리만 이동시켜도 된다. 나중에 push할 때 새롭게 top이 가리키는 자리에 새 요소가 들어와 대체할 수 있기 때문이다. (stack pointer을 이용하는 방법)

- 주로 스택의 크기를 미리 정해두고 사용한다. (예: 0으로 채워진 리스트)

  → 크기를 미리 정해둔 스택을 활용한다면, 스택이 꽉 차면 더이상 push를 할 수 없고, 스택이 비어있으면 pop이 안 된다.

  (스택의 크기를 정해두지 않는다면 `.append()`를 이용하여 push할 수 있다.)

  > ※ 참고
  >
  > 1차원 배열을 사용할 경우, 구현하기 용이하지만 스택의 크기를 변경하기 어렵다는 단점이 있다.
  >
  > ⇒ 동적 연결리스트를 활용하여 저장소를 동적으로 할당하는 방법을 사용할 수 있다. 이는 메모리 상에서 실제로 연결된 형태 대신에, 떨어진 덩어리를 만들어 연속된 공간이 아니라 분리된 공간에, 다음 정보의 위치에 대한 정보를 포함하여 저장하는 방법이다. 이 방법은 구현이 복잡하지만, 메모리를 효율적으로 활용할 수 있도록 해준다.

### 스택의 응용: 괄호검사

정상적인 괄호 쌍이 되기 위해서는:

- 여는 괄호와 닫는 괄호의 개수가 일치해야 한다.
- 왼쪽 괄호가 먼저 나온 상태에서 닫힌 괄호가 나와야 한다.
- 여는 괄호와 다는 괄호의 종류가 일치해야 한다.

**sol**

- 여는 괄호('(', '{')가 나오면 스택에 push하고, 닫는 괄호가 나오면 스택에서 요소를 pop한다.
  - pop 했을 때, 반환되는 괄호와 해당 괄호의 종류가 같아야 한다.
- 모든 요소의 push, pop이 끝난 후 stack은 모두 비어있어야 한다.

### 스택의 응용: function call

프로그램에서 함수 호출과 복귀에 따른 수행 순서를 관리할 때에도 스택 구조가 활용된다.

- 가장 마지막에 호출된 함수가 결과값을 상위 함수에 반환하고 실행을 완료, 복귀하는 LIFO 구조
- 함수 호출이 발생하면, 함수의 변수 및 복귀 주소 등의 정보가 스택 프레임(stack frame)에 저장되어 시스템 스택에 삽입된다. 실행이 끝나면, 스택 프레임이 삭제되며 복귀 주소로 돌아간다.
- 전체 프로그램이 수행되고 나면 스택 프레임은 공백이 된다.

![img](https://youshaohua.com/assets/img/post/simply-and-easily-understanding-function-call-stack-by-a-vision/thum.jpg)



## 2. 재귀호출

> 똑같이 생긴 함수를 여러 번 호출하는 것 (자기 자신을 호출하여 순환 수행)

- 호출 부분과 중단되는 부분(base case)으로 구성되어야 한다. 그래서 주로 `if~ else~` 구문으로 되어 있다.

- 함수를 간단하게 작성할 수 있지만, 깊이가 깊어지면 수행시간이 기하급수적으로 증가한다.

- 증가하는 방향으로 재귀호출을 한다면, 접근할 위치와 <u>경계값을 같이</u> 넘겨준다.

  예) 배열에 접근 — 접근할 위치, 배열의 크기, 찾으려는 값을 전달

![How is recursion used to compute the factorial function? - Quora](https://qph.fs.quoracdn.net/main-qimg-ad0f90f6d7b09a9c36a192f21293b17e.webp)

## 3. Memoization

> - 재귀함수의 *중복 호출 문제* 에 대처하기 위한 방법
> - 컴퓨터 프로그램을 실행할 때, 이전 계산의 결과값을 메모리에 저장하여 같은 계산을 반복하지 않도록 함으로써 실행속도를 향상시키는 기술
> - 동적계획법(DP)의 핵심

### 예) 피보나치

```python
def fibo_m(n):
    global memo
    if n >= 2 and len(memo) <= n:
        memo.append(fibo(n-1) + fibo(n-2))		# 리스트 memo에 계산에 활용할 수 있는 이전값이 저장됨
    return memo[n]

memo = [0, 1]
```



## 4. DP (Dynamic Programming, 동적 계획법)

> 최적화 알고리즘으로, 작은 부분 문제들을 해결함으로써 큰 문제를 해결하는 알고리즘
>
> - 반복 구조, 저장된 값에 접근, 길이만큼만 연산하면 됨
> - 구현 방식
>   - recursive: 재귀 사용
>   - iterative: 반복구조 (일반적인 DP)

### 방법

1) 수식으로 정리한다.
2) 구현 방법을 궁리한다 (어떤 게 적절할지)

### 예) 피보나치

```python
def fibo_d(n):
    f = [0, 1]
    
    for i in range(2, n+1):
        f.append(f[i-1] + f[n-2])
        
    return f[n]
```



## 5. DFS (Depth First Search, 깊이 우선 탐색)

> 시작 정점의 한 방향으로 갈 수 있을 때까지 깊이 탐색하다가, 갈 곳이 없으면 가장 최근에 지나온, 갈림길이 있는 정점으로 돌아와, 다른 방향으로의 탐색을 반복하여 모든 정점을 방문하는 순회방법
>
> - 탐색과 가장 최근의 정점으로 돌아가기를 해야 하므로, LIFO 구조의 스택을 사용할 수 있다.
> - 참고: BFS (Breadth First Search, 너비 우선 탐색)

- 스택을 썼기 때문에 DFS가 아니라, 경로를 후입선출로 꺼내기 위해 스택을 사용할 수 있다는 점에 유의하자.

### 스택을 사용한 DFS 알고리즘

준비물: stack, visited 배열, 시작점 v

1) 시작 정점 `v`를 결정한다. (문제에 따라 모든 점에서 각각 시작해 봐야 할 수도 있다.)

2) 직접 연결된 정점 중에서, 

   0. 방문 여부는 visited 배열로 관리한다.

   1) 방문하지 않은 정점 `w`가 있으면, `v`를 스택에 넣고, `w`를 새로운 `v`로 설정하여 반복한다.

   2) 방문하지 않은 정점이 없으면, 최근 정점으로 되돌아가기 위해 스택에서 pop한 정점을 `v`로 설정하고 반복한다.

3) 스택이 공백이 될 때까지 반복한다.

![animation of dfs](https://www.codesdope.com/staticroot/images/algorithm/dfs.gif)

※ 재귀로 DFS를 할 때는 스택을 사용하지 않는다. 이전 호출 단계에 방문 경로가 저장되어 있기 때문이다.

*끝*



